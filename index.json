[{"categories":["文档"],"content":"mysql8设置远程访问 # 登录 mysql -u root -p # 查看用户信息 select host,user,plugin,authentication_string from mysql.user; +-----------+------------------+-----------------------+------------------------------------------------------------------------+ | host | user | plugin | authentication_string | +-----------+------------------+-----------------------+------------------------------------------------------------------------+ | % | root | caching_sha2_password | $A$005$HF7;krfwhkKHp5fPenQm4J2dm/RJtbbyjtCUVdDCcboXQw3ALxsif/sS1 | | localhost | mysql.infoschema | caching_sha2_password | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED | | localhost | mysql.session | caching_sha2_password | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED | | localhost | mysql.sys | caching_sha2_password | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED | | localhost | root | mysql_native_password | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 | +-----------+------------------+-----------------------+------------------------------------------------------------------------+ # host为 % 表示不限制ip plugin 需要修改为 mysql_native_password ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123456'; ### 123456 mysql的登录密码 flush privileges; # 重新查看 plugin 已修改为 mysql_native_password select host,user,plugin,authentication_string from mysql.user; centOS7 获取ip地址 dhclient eth0 ip addr centOS7开启ssh 先检查有没有安装ssh服务：rpm -qa | grep ssh 如果没有安装ssh服务就安装 ： yum install openssh-server vi /etc/ssh/sshd_config # 开启Port 22、PermitRootLogin YES systemctl start sshd.service systemctl enable sshd.service ","date":"2021-06-09","objectID":"/20210609-unraid/:0:0","tags":["linux"],"title":"unraid使用手册","uri":"/20210609-unraid/"},{"categories":["文档"],"content":"sites ","date":"2021-04-19","objectID":"/20210419-hackintosh/:0:0","tags":["hackintosh"],"title":"hackintosh With OC","uri":"/20210419-hackintosh/"},{"categories":["文档"],"content":"查看端口占用 netstat -lnp|grep 8000 # 进程详细信息 tcp6 0 0 :::9000 :::* LISTEN 8808/main # 查看进程详细信息 kill进程 ps 8808 kill -9 11100 ","date":"2020-11-04","objectID":"/20201104-linux-command/:0:0","tags":["linux"],"title":"linux常用命令","uri":"/20201104-linux-command/"},{"categories":["code"],"content":" package main import ( \"encoding/json\" \"flag\" \"log\" \"net/http\" \"strings\" ) type CommandModel struct { Port *string } var commandModel CommandModel func main() { initCommandModel() http.HandleFunc(\"/\", ExampleHandler) log.Printf(\"running at %s...\", *commandModel.Port) if err := http.ListenAndServe(\":\"+*commandModel.Port, nil); err != nil { panic(err) } } func initCommandModel() { commandModel.Port = flag.String(\"p\", \"8080\", \"请输入端口号\") flag.Parse() } func ExampleHandler(w http.ResponseWriter, r *http.Request) { w.Header().Add(\"Content-Type\", \"application/json\") resp, _ := json.Marshal(map[string]string{ \"ip\": GetIP(r), }) w.Write(resp) } // GetIP gets a requests IP address by reading off the forwarded-for // header (for proxies) and falls back to use the remote address. func GetIP(r *http.Request) string { forwarded := r.Header.Get(\"X-FORWARDED-FOR\") if forwarded != \"\" { return forwarded } arr := strings.Split(r.RemoteAddr,\":\") if len(arr) \u003e 0{ return arr[0] } return r.RemoteAddr } ","date":"2020-11-04","objectID":"/20201104-go-remoteaddr/:0:0","tags":["go"],"title":"go 获取http请求ip","uri":"/20201104-go-remoteaddr/"},{"categories":["文档"],"content":"web通过发送http请求，后端使用mqtt发现请求控制设备 go Arduino 读取引脚状态 int value = digitalRead(pin); web ","date":"2020-10-29","objectID":"/20201029-smart-home/:0:0","tags":["lot"],"title":"Smart Home","uri":"/20201029-smart-home/"},{"categories":["web"],"content":"生命周期函数 只能在setup里面使用 setup() { onBeforeMount(() =\u003e { console.log('onBeforeMount!'); }); onMounted(() =\u003e { console.log('mounted!'); }); onUpdated(() =\u003e { console.log('updated!'); }); onUnmounted(() =\u003e { console.log('unmounted!'); }); return {}; } ref,reactive,isRef,isReactive ref()是用来根据给定的值（number、string、bool等）创建一个响应式的数据对象，ref()函数调用的返回值是个对象，这对象只包含一个value属性，只在setup函数内容访问ref函数需要添加.value \u003ctemplate\u003e \u003cp\u003e{{ name }}\u003c/p\u003e \u003cp\u003e{{ refName }}\u003c/p\u003e \u003cvan-button @click=\"changeValue\" type=\"primary\"\u003eclick\u003c/van-button\u003e \u003cp\u003e用户信息：{{ user.name }}-{{ user.age }}-{{ user.refName }}\u003c/p\u003e \u003cvan-button @click=\"changeUser('张三', 100)\" type=\"primary\"\u003echangeUser\u003c/van-button\u003e \u003c/template\u003e \u003cscript lang=\"ts\"\u003e import { defineComponent, reactive, ref } from 'vue'; export default defineComponent({ name: 'HOME', setup() { let name = 'lppx'; const refName = ref\u003cstring\u003e('refName'); const changeValue = () =\u003e { name = '123'; // 非响应式数据 ，不会更新到dom中 refName.value = 'lppx'; console.log(name, refName.value); }; const user = reactive({ name: 'lppx', age: 22, refName, // reactive中使用ref值 }); const changeUser = (name: string, age: number) =\u003e { user.name = name; user.age = age; //通过reactive 来获取或设置ref 的值时,不需要使用.value属性 console.log(user.refName); user.refName = 'reactive中使用ref值不需要添加.value'; }; console.log('是否为ref()创建出来的对象', isRef(name)); // false console.log('是否为ref()创建出来的对象', isRef(refName)); // true console.log('是否为ref()创建出来的对象', isRef(user)); // false console.log('是否为reactive()创建出来的对象', isReactive(user)); // true return { name, refName, changeValue, user, changeUser, }; }, }); \u003c/script\u003e \u003cstyle lang=\"scss\" scoped\u003e\u003c/style\u003e toRefs toRefs()将reactive()创建出来的响应式对象转为普通对象，但对象的属性都是ref()类型的响应式对象 在使用不需要通过user.name访问 \u003ctemplate\u003e \u003cp\u003e用户信息：{{ name }}-{{ age }}\u003c/p\u003e \u003cp\u003e用户信息：{{ name1 }}-{{ age1 }}\u003c/p\u003e \u003c/template\u003e \u003cscript lang=\"ts\"\u003e import { defineComponent, reactive, toRefs } from 'vue'; function useUser() { const state = reactive({ name: 'use-lppx', age: 99, }); return toRefs(state); } export default defineComponent({ name: 'HOME', setup() { const user = reactive({ name1: 'lppx', age1: 22, }); const { name, age } = useUser(); return { ...toRefs(user), name, age, }; }, }); \u003c/script\u003e \u003cstyle lang=\"scss\" scoped\u003e\u003c/style\u003e watchEffect watch \u003ctemplate\u003e \u003ch1\u003ehome\u003c/h1\u003e \u003cdiv\u003e {{ count }} \u003cvan-button @click=\"setCount\" type=\"primary\"\u003e+\u003c/van-button\u003e \u003cvan-button @click=\"stopWatchEffect\" type=\"primary\"\u003estopWatchEffect\u003c/van-button\u003e \u003cvan-button @click=\"stopWatch\" type=\"primary\"\u003estopWatch\u003c/van-button\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript lang=\"ts\"\u003e import { computed, defineComponent, reactive, ref, toRefs, watch, watchEffect } from 'vue'; export default defineComponent({ name: 'HOME', setup() { const count = ref(1); const setCount = () =\u003e { count.value++; }; // watchEffect执行就监听 const stopWatchEffect = watchEffect(() =\u003e { console.log('watchEffect count:', count.value); }); // watch 懒监听，当value改变才触发 const stopWatch = watch( () =\u003e count.value, (newValue, oldValue) =\u003e { console.log('watch new:', newValue); console.log('watch old:', oldValue); } ); return { count, setCount, stopWatchEffect, stopWatch, }; }, }); \u003c/script\u003e \u003cstyle lang=\"scss\" scoped\u003e\u003c/style\u003e ","date":"2020-10-26","objectID":"/20201026-vue3-learn/:0:0","tags":["vue"],"title":"Vue3学习","uri":"/20201026-vue3-learn/"},{"categories":["文档"],"content":"安装nginx sudo yum -y install nginx # 安装 nginx sudo yum remove nginx # 卸载 nginx 配置nginx yum安装方式 ，配置文件目录在/etc/nginx/nginx.conf 也可以到conf.d文件夹下，新建web.conf写入配置 常用配置 server { listen 9001; index index.html index.htm index.php; root /var/www/lppx-on-hugo/public; #error_page 404 /404.html; #include enable-php.conf; location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ { expires 30d; } location ~ .*\\.(js|css)?$ { expires 12h; } location ~ /\\. { deny all; } access_log /www/wwwlogs/access.log; } 制作反向代理配置 # server { server_name h.linpx.cn; listen 80; location / { proxy_pass_header Server; proxy_redirect off; proxy_pass http://127.0.0.1:7017; } } sudo systemctl start nginx # 启动 sudo systemctl enable nginx # 设置开机启动 sudo service nginx start # 启动 nginx 服务 sudo service nginx stop # 停止 nginx 服务 sudo service nginx restart # 重启 nginx 服务 sudo service nginx reload # 重新加载配置，一般是在修改过 nginx 配置文件时使用。 ","date":"2020-10-25","objectID":"/20201025-centos-nginx/:0:0","tags":["linux"],"title":"centos7安装nginx","uri":"/20201025-centos-nginx/"},{"categories":["文档"],"content":"编写配置文件 cd /etc/systemd/system vi pxtool.service # pxtool.service [Unit] Description=PXApi [Service] Type=simple Restart=always RestartSec=5s ExecStart=/root/go/src/gin-target/main WorkingDirectory=/root/go/src/gin-target [Install] WantedBy=multi-user.target 每次修改 ExecStart 需要执行systemctl daemon-reload # 启动 systemctl start pxtool.service # 查看状态 systemctl status pxtool.service # 自启动 systemctl enable pxtool.service 常用 service 操作 # 自启动 systemctl enable nginx.service # 禁止自启动 systemctl disable nginx.service # 启动服务 systemctl start nginx.service # 停止服务 systemctl stop nginx.service # 重启服务 systemctl restart nginx.service # 查看Unit定义文件 systemctl cat nginx.service # 编辑Unit定义文件 systemctl edit nginx.service # 重新加载Unit定义文件 systemctl reload nginx.service # 列出已启动的所有unit，就是已经被加载到内存中 systemctl list-units # 列出系统已经安装的所有unit，包括那些没有被加载到内存中的unit systemctl list-unit-files # 查看服务的日志 journalctl -u nginx.service # 还可以配合`-b`一起使用，只查看自本次系统启动以来的日志 # 查看所有target下的unit systemctl list-unit-files --type=target # 查看默认target，即默认的运行级别。对应于旧的`runlevel`命令 systemctl get-default # 设置默认的target systemctl set-default multi-user.target # 查看某一target下的unit systemctl list-dependencies multi-user.target # 切换target，不属于新target的unit都会被停止 systemctl isolate multi-user.target systemctl poweroff # 关机 systemctl reboot # 重启 systemctl rescue # 进入rescue模式 相关文档 systemctl部署go config # frp [Unit] Description=PXApi [Service] Type=simple ExecStart=/home/lib/frp/frps -c /home/lib/frp/frps.ini [Install] WantedBy=multi-user.target ","date":"2020-10-22","objectID":"/20201022-systemctl-go/:0:0","tags":["go"],"title":"使用systemctl部署golang项目","uri":"/20201022-systemctl-go/"},{"categories":["文档"],"content":"安装并运行hugo(window) hugo下载地址 解压文件 并添加path到环境变量中 # 新建站点 hugo new blog # 创建页面 hugo new about.md hugo new posts/first.md 安装主题 git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt 主题文档说明 创建git仓库 把hugo整个文件推到仓库，到github创建Atcions工作流模板 完整工作流模板 # .github/workflows/main.yml # This is a basic workflow to help you get started with Actions name: Deploy on push events # Controls when the action will run. Triggers the workflow on push events # but only for the master branch on: push: branches: [master] # A workflow run is made up of one or more jobs that can run sequentially or in parallel jobs: # This workflow contains a single job called \"build\" build: # The type of runner that the job will run on runs-on: ubuntu-latest # Steps represent a sequence of tasks that will be executed as part of the job steps: # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it - uses: actions/checkout@v2 # with: # submodules: 'recursive' # Use ssh-agent to cache ssh keys - uses: webfactory/ssh-agent@v0.2.0 with: ssh-private-key: | ${{ secrets.BLOG_DEPLOY_KEY }} - name: Scan public keys run: | ssh-keyscan www.linpx.cn \u003e\u003e ~/.ssh/known_hosts - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \"0.75.1\" extended: true - name: Build run: | hugo --minify - name: Deploy run: | rsync -av --delete public root@www.linpx.cn:/www/lppx-on-hugo 生成SSH密钥 ssh-keygen -t ed25519 -f ~/.ssh/blog_deploy_key 将公钥~/.ssh/blog_deploy_key.pub内容贴到VPS的~/.ssh/authorized_keys，将私钥~/.ssh/blog_deploy_key内容添加到GitHub仓库的Secrets中并命名为BLOG_DEPLOY_KEY 相关资料 部署hugo到VPS ","date":"2020-10-22","objectID":"/20201022-install-hugo/:0:0","tags":["hugo"],"title":"通过github Actions自动部署hugo到VPS","uri":"/20201022-install-hugo/"},{"categories":null,"content":"lppx很闲! ","date":"2020-10-22","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"}]